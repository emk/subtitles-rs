//! Export to Anki via Anki-Connect.

use std::path::{Path, PathBuf};

use anyhow::{anyhow, Context as _};
use log::debug;
use regex::Regex;

use crate::{
    align::unique_foreign_subs,
    contexts::ItemsInContextExt,
    export::{
        anki::connect::{
            AddNotesRequest, AnkiConnect, CanAddNotesWithErrorDetailRequest,
            DeckNamesRequest, ModelNamesRequest, Note, NoteOptions,
            StoreMediaFileRequest, VersionRequest,
        },
        Exporter,
    },
    srt::Subtitle,
    time::seconds_to_hhmmss_sss,
    ui::{ProgressConfig, Ui},
    Result,
};

pub(crate) use self::models::AudioNote;

mod connect;
mod models;

/// Attempt to guess a reasonable episode number, based on the file name.
/// Honestly, this might be a bit too clever--the original subs2srs CSV
/// format something this as part of a sort key, but we may be able to do a
/// lot better if we rethink the CSV columns we're exporting.
fn episode_prefix(file_stem: &str) -> String {
    let re = Regex::new(r"[0-9][-_.0-9]+$").unwrap();
    re.captures(file_stem)
        .map(|c| {
            let ep = c.get(0).unwrap().as_str();
            format!("{} ", ep.replace("-", ".").replace("_", "."))
        })
        .unwrap_or_else(|| "".to_owned())
}

#[test]
fn test_episode_prefix() {
    assert_eq!("01.02 ", episode_prefix("series_01_02"));
    assert_eq!("", episode_prefix("film"));
}

/// Information about a media file we're exporting.
pub(crate) struct AnkiExportMedia {
    pub(crate) filename: String,
    pub(crate) path: PathBuf,
}

impl AnkiExportMedia {
    pub(crate) fn new(dir: &Path, filename: &str) -> Self {
        Self {
            filename: filename.to_owned(),
            path: dir.join(filename),
        }
    }

    pub(crate) fn full_path_string(&self) -> Result<String> {
        // Canonicalize and convert to a string.
        self.path
            .canonicalize()
            .with_context(|| {
                format!("Could not canonicalize path: {}", self.filename)
            })?
            .to_str()
            .ok_or_else(|| {
                anyhow!(
                    "Could not convert path to a UTF-8 string: {}",
                    self.filename
                )
            })
            .map(|s| s.to_owned())
    }
}

/// Information about a single export.
pub(crate) struct AnkiExport {
    pub(crate) notes: Vec<AudioNote>,
    pub(crate) media: Vec<AnkiExportMedia>,
}

/// Export media using `exporter` and return a list of Anki notes. This is a
/// helper function used by Anki-related exporters.
pub(crate) fn export_anki_helper(
    exporter: &mut Exporter,
    skip_duplicates: bool,
) -> Result<AnkiExport> {
    let foreign_lang = exporter.foreign().language;
    let prefix = episode_prefix(exporter.file_stem());

    // Align our input files, filtering out ones with no foreign-language
    // text, because those make lousy SRS cards.  (Yes, it seems like it
    // should work, but I've seen multiple people try it now, and they're
    // maybe only 20% as effective as cards with foreign-language text, at
    // least for people below CEFRL C1.)
    let mut aligned: Vec<(Option<Subtitle>, Option<Subtitle>)> = exporter
        .align()
        .iter()
        // The double ref `&&` is thanks to `filter`'s type signature.
        .filter(|&&(ref f, _)| f.is_some())
        .cloned()
        .collect();
    if skip_duplicates {
        aligned = unique_foreign_subs(aligned);
    }

    // Output our media and collect our card information.
    let mut notes = vec![];
    let mut media = vec![];
    for ctx in aligned.items_in_context() {
        // We have a `Context<&(Option<Subtitle>, Option<Subtitle>)>`
        // containing the previous subtitle pair, the current subtitle
        // pair, and the next subtitle pair.  We want to split apart that
        // tuple and flatten any nested `Option<&Option<T>>` types into
        // `Option<&T>`.
        let foreign = ctx.map(|&(ref f, _)| f).flatten();
        let native = ctx.map(|&(_, ref n)| n).flatten();

        if let Some(curr) = foreign.curr {
            let period = curr.period.grow(1.5, 1.5);

            let image_filename = exporter.schedule_image_export(period.midpoint());
            let audio_filename = exporter.schedule_audio_export(foreign_lang, period);

            if let Some(image_filename) = &image_filename {
                media.push(AnkiExportMedia::new(exporter.dir(), image_filename));
            }
            media.push(AnkiExportMedia::new(exporter.dir(), &audio_filename));

            // Try to emulate something like the wierd sort-key column
            // generated by subs2srs without requiring the user to always
            // pass in an explicit episode number.
            let sort_key =
                format!("{}{}", &prefix, &seconds_to_hhmmss_sss(period.begin()));

            notes.push(AudioNote {
                sound: format!("[sound:{}]", &audio_filename),
                time: sort_key,
                source: exporter.title().to_owned(),
                image: image_filename.map(|ip| format!("<img src=\"{}\" />", ip)),
                foreign_curr: foreign.curr.map(|s| s.plain_text()),
                native_curr: native.curr.map(|s| s.plain_text()),
                foreign_prev: foreign.prev.map(|s| s.plain_text()),
                native_prev: native.prev.map(|s| s.plain_text()),
                foreign_next: foreign.next.map(|s| s.plain_text()),
                native_next: native.next.map(|s| s.plain_text()),
                hint: None,
                notes: None,
            });
        }
    }
    Ok(AnkiExport { notes, media })
}

/// Options for exporting to Anki.
pub struct AnkiExportOptions {
    /// The name of the deck to export to.
    pub deck: String,
    /// The tags to apply to the exported notes.
    pub tags: Vec<String>,
    /// Skip duplicate subtitles.
    pub skip_duplicates: bool,
}

/// Export to Anki.
pub async fn export_anki(
    ui: &Ui,
    exporter: &mut Exporter,
    options: AnkiExportOptions,
) -> Result<()> {
    // Make sure we can talk to Anki-Connect.
    let client = AnkiConnect::new();
    let version = client.request(VersionRequest).await.context(
        "Could not connect to AnkiConnect (see `substudy export anki --help` for troubleshooting)",
    )?;
    debug!("Anki-Connect version: {}", version);

    // Make sure our deck exists.
    let deck_names = client
        .request(DeckNamesRequest)
        .await
        .context("error fetching deck names from Anki-Connect")?;
    if !deck_names.iter().any(|n| n == &options.deck) {
        return Err(anyhow!(
            "deck not found: {:?} (please create it in Anki first)",
            options.deck
        ));
    }

    // Export our notes and media (to a temporary directory).
    let exporting = export_anki_helper(exporter, options.skip_duplicates)?;
    exporter.finish_exports(ui).await?;
    let model = &models::AUDIO_MODEL;

    // Make sure our model exists.
    let model_names = client
        .request(ModelNamesRequest)
        .await
        .context("error fetching model names from Anki-Connect")?;
    if !model_names.iter().any(|n| n == model.model_name) {
        debug!("Creating model: {}", model.model_name);
        client
            .request(model)
            .await
            .context("error creating model with Anki-Connect")?;
    }

    // Add our media files to Anki.
    let media_prog_conf = ProgressConfig {
        emoji: "üé•",
        msg: "Adding media",
        done_msg: "Added media",
    };
    let pb = ui.new_progress_bar(&media_prog_conf, exporting.media.len() as u64);
    for media in exporting.media {
        client
            .request(StoreMediaFileRequest {
                filename: media.filename.clone(),
                path: media.full_path_string()?,
            })
            .await?;
        pb.inc(1);
    }
    ui.finish(&media_prog_conf, pb);

    // Add our notes.
    let note_prog_conf = ProgressConfig {
        emoji: "üóíÔ∏è",
        msg: "Adding notes",
        done_msg: "Added notes",
    };
    let spinner = ui.new_spinner(&note_prog_conf);
    let notes = exporting
        .notes
        .into_iter()
        .map(|fields| Note {
            deck_name: options.deck.clone(),
            model_name: model.model_name.to_owned(),
            fields,
            options: NoteOptions::default(),
            tags: options.tags.clone(),
        })
        .collect::<Vec<_>>();
    let error_details = client
        .request(CanAddNotesWithErrorDetailRequest {
            notes: notes.clone(),
        })
        .await?;
    if error_details.iter().any(|ed| !ed.can_add) {
        let mut error_messages = error_details
            .into_iter()
            .filter_map(|ed| ed.error)
            .collect::<Vec<_>>();
        error_messages.sort();
        error_messages.dedup();
        return Err(anyhow!(
            "error adding notes to Anki: {}",
            error_messages.join(", ")
        ));
    }

    let results = client.request(AddNotesRequest { notes }).await?;
    ui.finish(&note_prog_conf, spinner);
    if results.iter().any(|r| r.is_none()) {
        return Err(anyhow!("error adding notes to Anki"));
    }

    Ok(())
}
